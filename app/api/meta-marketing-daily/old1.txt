import { NextResponse } from "next/server";
import {
  FacebookAdsApi,
  AdAccount,
  AdCreative,
} from "facebook-nodejs-business-sdk";
import { createClient } from "@/utils/supabase/server";
import { SupabaseClient } from "@supabase/supabase-js";

// Dynamic route configuration to fix static bailout error
export const dynamic = "force-dynamic";

// Using duplicate tables for testing purposes, to avoid affecting production data
// The _duplicate suffix is used for all Supabase tables referenced in this file

// Import these types for type checking but not for actual usage

// Helper functions to safely parse strings to numbers
function safeParseInt(value: string | undefined, defaultValue = 0): number {
  if (value === undefined) return defaultValue;
  const parsed = parseInt(value, 10);
  return isNaN(parsed) ? defaultValue : parsed;
}

function safeParseFloat(value: string | undefined, defaultValue = 0): number {
  if (value === undefined) return defaultValue;
  const parsed = parseFloat(value);
  return isNaN(parsed) ? defaultValue : parsed;
}

// Interface for entities that support the getInsights method
interface InsightCapableEntity {
  id: string;
  getInsights: (
    fields: string[],
    options: Record<string, unknown>
  ) => Promise<unknown[]>;
}

// Interface for processed insights results
interface InsightResult {
  impressions?: string;
  clicks?: string;
  reach?: string;
  spend?: string;
  cpc?: string;
  cpm?: string;
  ctr?: string;
  frequency?: string;
  objective?: string;
  action_values?: Array<{ action_type: string; value: string }>;
  actions?: Array<{ action_type: string; value: string }>;
  cost_per_action_type?: Array<{ action_type: string; value: string }>;
  cost_per_unique_click?: string;
  outbound_clicks?: Array<{ action_type: string; value: string }>;
  outbound_clicks_ctr?: Array<{ action_type: string; value: string }>;
  website_ctr?: Array<{ action_type: string; value: string }>;
  website_purchase_roas?: Array<{ action_type: string; value: string }>;
  [key: string]: unknown;
}

interface RateLimitInfo {
  usage_percent: number;
  call_count: number;
  total_cputime: number;
  total_time: number;
  estimated_time_to_regain_access: number;
  business_use_case?: string;
  reset_time_duration?: number;
}

// Enhanced rate limiting configuration based on Meta's documentation
const RATE_LIMIT_CONFIG = {
  // API Tier limits
  DEVELOPMENT: {
    MAX_SCORE: 60,
    DECAY_TIME: 300, // 300 seconds
    BLOCK_TIME: 300, // 300 seconds
    ADS_MANAGEMENT_HOURLY: 300, // 300 calls per hour in dev tier
    INSIGHTS_HOURLY: 600, // 600 calls per hour in dev tier
  },
  STANDARD: {
    MAX_SCORE: 9000,
    DECAY_TIME: 300, // 300 seconds
    BLOCK_TIME: 60, // 60 seconds
    ADS_MANAGEMENT_HOURLY: 100000, // 100k calls per hour in standard tier
    INSIGHTS_HOURLY: 190000, // 190k calls per hour in standard tier
  },
  // Operation costs
  POINTS: {
    READ: 1,
    WRITE: 3,
    INSIGHTS: 2, // Insights calls are more expensive
  },
  // Batch and delay settings
  BATCH_SIZE: 25, // Reduced from 50 to ensure smaller batches
  MIN_DELAY: 1000, // 1 second minimum delay
  BURST_DELAY: 2000, // 2 seconds for potential burst
  INSIGHTS_DELAY: 3000, // 3 seconds for insights calls
};

// Initialize Meta API configuration
const META_CONFIG = {
  accessToken: process.env.META_ACCESS_TOKEN!,
};

// Table configuration
let CAMPAIGN_TABLE = "meta_campaigns"; // Default table for non-duplicate data

// Helper function to delay execution
const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

// Helper function to calculate dynamic delay based on recent API usage
function calculateDynamicDelay(endpoint: string, points: number): number {
  const baseDelay = endpoint.includes("insights")
    ? RATE_LIMIT_CONFIG.INSIGHTS_DELAY
    : RATE_LIMIT_CONFIG.MIN_DELAY;

  // Increase delay as points accumulate
  const pointMultiplier = Math.ceil(points / 10); // Every 10 points increases delay
  return Math.min(baseDelay * pointMultiplier, 5000); // Cap at 5 seconds
}

// Queue system for rate limit handling
const rateLimitQueue = {
  isProcessing: false,
  lastErrorTime: 0,
  consecutiveErrors: 0,
  waitTime: 0,
};

// Enhanced backoff strategy with Meta's guidelines
function getBackoffDelay(retryCount: number, errorCode?: number): number {
  const baseDelay = 1000; // Start with 1 second
  const maxDelay = 300000; // Max 5 minutes

  // If we've hit consecutive rate limits, increase the base delay
  if (rateLimitQueue.consecutiveErrors > 0) {
    const consecutiveMultiplier = Math.min(
      Math.pow(2, rateLimitQueue.consecutiveErrors),
      16
    );
    return Math.min(baseDelay * consecutiveMultiplier, maxDelay);
  }

  // Exponential backoff with jitter
  const exponentialDelay = baseDelay * Math.pow(2, retryCount);
  const jitter = Math.random() * 1000;
  return Math.min(exponentialDelay + jitter, maxDelay);
}

// Helper function to track API metrics
async function trackApiMetrics(
  supabase: SupabaseClient,
  accountId: string,
  endpoint: string,
  callType: string,
  points: number,
  success: boolean,
  errorCode?: string,
  errorMessage?: string
) {
  try {
    console.log(
      `Tracking API metrics for account ${accountId}, endpoint ${endpoint}...`
    );
    const { error } = await supabase.from("meta_api_metrics").insert([
      {
        account_id: accountId,
        endpoint,
        call_type: callType,
        points_used: points,
        success,
        error_code: errorCode,
        error_message: errorMessage,
      },
    ]);

    if (error) {
      console.error("Error inserting into meta_api_metrics:", error.message);
      console.error("Error details:", JSON.stringify(error));

      // Check for specific error conditions
      if (error.message.includes("foreign key constraint")) {
        console.error(
          `Foreign key constraint failed: Account ID ${accountId} might not exist in the accounts table`
        );
      } else if (error.message.includes("permission denied")) {
        console.error(
          "Permission denied for inserting into meta_api_metrics table. Check Supabase RLS policies."
        );
      }
    } else {
      console.log(`Successfully tracked API metrics for ${endpoint}`);
    }
  } catch (error) {
    console.error("Exception tracking API metrics:", error);
    if (error instanceof Error) {
      console.error("Error name:", error.name);
      console.error("Error message:", error.message);
      console.error("Error stack:", error.stack);
    }
  }
}

// Enhanced retry mechanism with rate limit awareness
async function withRateLimitRetry<T>(
  operation: () => Promise<T>,
  context: {
    accountId: string;
    endpoint: string;
    callType: string;
    points: number;
    supabase: SupabaseClient;
  }
): Promise<T> {
  let retries = 0;
  const maxRetries = 5;
  const isInsights = context.endpoint.includes("insights");
  const operationId = `${context.endpoint}-${Date.now()}`;

  console.log(`[${operationId}] Starting operation: ${context.endpoint}`);

  while (true) {
    try {
      // Check if we're in a rate limit cool-down period
      if (rateLimitQueue.isProcessing) {
        const timeSinceError = Date.now() - rateLimitQueue.lastErrorTime;
        if (timeSinceError < rateLimitQueue.waitTime) {
          const remainingWait = rateLimitQueue.waitTime - timeSinceError;
          console.log(
            `[${operationId}] Rate limit cool-down in progress. Waiting ${remainingWait}ms before retry...`
          );
          await delay(remainingWait);
        }
      }

      // Add pre-emptive delay based on operation type
      const preDelay = calculateDynamicDelay(context.endpoint, context.points);
      console.log(`[${operationId}] Adding pre-emptive delay of ${preDelay}ms`);
      await delay(preDelay);

      console.time(`${operationId}-execution`);
      console.log(`[${operationId}] Executing operation...`);
      const result = await operation();
      console.timeEnd(`${operationId}-execution`);
      console.log(`[${operationId}] Operation completed successfully`);

      // Reset rate limit queue on success
      rateLimitQueue.isProcessing = false;
      rateLimitQueue.consecutiveErrors = 0;
      rateLimitQueue.waitTime = 0;

      // Track successful API call
      await trackApiMetrics(
        context.supabase,
        context.accountId,
        context.endpoint,
        context.callType,
        context.points,
        true
      );

      return result;
    } catch (error: unknown) {
      console.timeEnd(`${operationId}-execution`);
      console.error(`[${operationId}] Operation failed:`, error);

      try {
        // Log detailed error information
        if (typeof error === "object" && error !== null) {
          console.error(`[${operationId}] Error details:`, {
            name: (error as any).name,
            message: (error as any).message,
            stack: (error as any).stack,
            response: (error as any).response,
          });
        }

        const apiError = error as {
          response?: {
            error?: { code?: number; message?: string; type?: string };
            statusCode?: number;
          };
          message?: string;
        };

        // Log additional API error information
        if (apiError.response?.error) {
          console.error(`[${operationId}] Facebook API Error:`, {
            statusCode: apiError.response.statusCode,
            code: apiError.response.error.code,
            message: apiError.response.error.message,
            type: apiError.response.error.type,
          });
        }

        const errorCode = apiError?.response?.error?.code;
        const isRateLimit = [17, 80000, 80003, 80004, 4, 613].includes(
          errorCode || 0
        );

        // Track failed API call
        await trackApiMetrics(
          context.supabase,
          context.accountId,
          context.endpoint,
          context.callType,
          context.points,
          false,
          errorCode?.toString(),
          apiError?.response?.error?.message
        );

        if (isRateLimit) {
          // Update rate limit queue
          rateLimitQueue.isProcessing = true;
          rateLimitQueue.lastErrorTime = Date.now();
          rateLimitQueue.consecutiveErrors++;

          // Calculate wait time based on consecutive errors
          rateLimitQueue.waitTime = getBackoffDelay(retries, errorCode);

          if (retries >= maxRetries) {
            console.log(
              `[${operationId}] Max retries (${maxRetries}) reached for rate limit. Throwing error.`
            );
            throw error;
          }

          console.log(
            `[${operationId}] Rate limit hit on ${
              context.endpoint
            }. Consecutive errors: ${
              rateLimitQueue.consecutiveErrors
            }. Waiting ${rateLimitQueue.waitTime}ms before retry ${
              retries + 1
            }/${maxRetries}...`
          );

          await delay(rateLimitQueue.waitTime);
          retries++;

          // For insights API, add extra delay
          if (isInsights) {
            await delay(RATE_LIMIT_CONFIG.INSIGHTS_DELAY);
          }

          continue;
        }

        // For non-rate limit errors, throw immediately
        throw error;
      } catch (logError) {
        console.error(`[${operationId}] Error while handling error:`, logError);
        throw error; // Still throw the original error
      }
    }
  }
}

// Helper function to get insights with rate limiting and error handling
async function getInsights(
  entity: InsightCapableEntity,
  supabase: SupabaseClient,
  accountId: string,
  dateRange: { since: string; until: string }
): Promise<InsightResult | null> {
  return withRateLimitRetry(
    async () => {
      console.log(
        "Fetching insights for entity:",
        entity.id,
        "with date range:",
        dateRange
      );

      const insights = await entity.getInsights(
        [
          "impressions",
          "clicks",
          "reach",
          "spend",
          "cpc",
          "cpm",
          "ctr",
          "frequency",
          "objective",
          "action_values",
          "actions",
          "cost_per_action_type",
          "cost_per_unique_click",
          "outbound_clicks",
          "outbound_clicks_ctr",
          "website_ctr",
          "website_purchase_roas",
        ],
        {
          time_range: dateRange,
          level: "ad",
          breakdowns: [],
        }
      );

      const processedInsights = (insights?.[0] as InsightResult) || null;
      return processedInsights;
    },
    {
      accountId,
      endpoint: "insights",
      callType: "READ",
      points: RATE_LIMIT_CONFIG.POINTS.READ,
      supabase,
    }
  );
}

// Helper function to get date range for last 6 months
function getLast6MonthsDateRange() {
  const endDate = new Date();
  const startDate = new Date();
  startDate.setMonth(startDate.getMonth() - 6);
  return {
    since: startDate.toISOString().split("T")[0],
    until: endDate.toISOString().split("T")[0],
  };
}

// Helper function to get date range for last 24 hours - keep for reference
function getLast24HoursDateRange() {
  const endDate = new Date();
  const startDate = new Date();
  startDate.setHours(startDate.getHours() - 24);
  return {
    since: startDate.toISOString().split("T")[0],
    until: endDate.toISOString().split("T")[0],
  };
}

// GET handler for daily marketing data
export async function GET(request: Request) {
  console.log("=== Starting Meta Marketing Daily API request ===");
  console.time("total-request-time");
  const supabase = await createClient();
  console.log("Supabase client created");

  // Test database connection
  try {
    console.log("Testing database connection...");
    const { data, error } = await supabase
      .from("meta_api_metrics")
      .select("*")
      .limit(1);

    console.log("meta_api_metrics", data, error);

    if (error) {
      console.error("Database connection test failed:", error);
    } else {
      console.log("Database connection test successful", {
        rowCount: data?.length || 0,
      });
    }

    // Check if meta_campaigns table exists
    console.log("Checking if meta_campaigns table exists...");
    try {
      const { data, error: tableCheckError } = await supabase
        .from("meta_campaigns")
        .select("*")
        .limit(1);
      console.log("meta_campaigns", data, error);

      if (
        tableCheckError &&
        tableCheckError.message.includes("does not exist")
      ) {
        console.error("Table meta_campaigns does not exist, aborting");
        return NextResponse.json(
          { error: "Required tables do not exist" },
          { status: 500 }
        );
      } else {
        // Table exists, use it
        CAMPAIGN_TABLE = "meta_campaigns";
        console.log("Using table: meta_campaigns");
      }
    } catch (tableError) {
      console.error("Error checking table existence:", tableError);
      // Fall back to default table
      CAMPAIGN_TABLE = "meta_campaigns";
    }
  } catch (dbTestError) {
    console.error("Database connection test threw an exception:", dbTestError);
  }

  try {
    const { searchParams } = new URL(request.url);
    const accountId = searchParams.get("accountId");
    const batchSize = parseInt(searchParams.get("batchSize") || "10", 10);
    const maxCampaigns = parseInt(searchParams.get("maxCampaigns") || "50", 10);

    if (!accountId) {
      console.log("Error: Account ID is missing");
      return NextResponse.json(
        { error: "Account ID is required" },
        { status: 400 }
      );
    }

    console.log(
      `Request for account: ${accountId} (batch size: ${batchSize}, max: ${maxCampaigns})`
    );

    // Initialize Facebook API
    console.log("Initializing Facebook API...");

    // Validate access token exists
    if (!META_CONFIG.accessToken) {
      console.error("META_ACCESS_TOKEN is not configured");
      return NextResponse.json(
        {
          error: "META_ACCESS_TOKEN is not configured properly",
          details:
            "The Meta Marketing API access token is missing. Please check your environment variables.",
        },
        { status: 500 }
      );
    }

    let api;
    let account;
    try {
      api = FacebookAdsApi.init(META_CONFIG.accessToken);
      api.setDebug(true);
      account = new AdAccount(accountId);
      console.log("Facebook API initialized");
    } catch (apiInitError) {
      console.error("Failed to initialize Facebook API:", apiInitError);
      return NextResponse.json(
        {
          error: "Failed to initialize Facebook API",
          details:
            apiInitError instanceof Error
              ? apiInitError.message
              : String(apiInitError),
        },
        { status: 500 }
      );
    }

    // Get the date range for the last 24 hours
    const dateRange = getLast24HoursDateRange();
    console.log(
      `Fetching data for date range: ${dateRange.since} to ${dateRange.until}`
    );

    // First check if the account has any activity in the last 24 hours
    console.log("Checking for account activity in the last 24 hours...");
    try {
      const accountInsights = await withRateLimitRetry(
        async () => {
          return account.getInsights(["impressions", "clicks", "spend"], {
            time_range: dateRange,
            level: "account",
            breakdowns: [],
          });
        },
        {
          accountId,
          endpoint: "account_insights",
          callType: "READ",
          points: RATE_LIMIT_CONFIG.POINTS.READ,
          supabase,
        }
      );

      // Check if there's any activity
      const hasActivity =
        accountInsights &&
        accountInsights.length > 0 &&
        (safeParseInt(accountInsights[0]?.impressions) > 0 ||
          safeParseInt(accountInsights[0]?.clicks) > 0 ||
          safeParseFloat(accountInsights[0]?.spend) > 0);

      console.log(
        `Activity check result: hasActivity=${hasActivity}, impressions=${
          accountInsights?.[0]?.impressions || 0
        }, clicks=${accountInsights?.[0]?.clicks || 0}, spend=${
          accountInsights?.[0]?.spend || 0
        }`
      );

      if (!hasActivity) {
        console.log(
          `No activity found in the last 24 hours for account ${accountId}`
        );
        return NextResponse.json({
          message: "No activity found in the last 24 hours",
          dateRange,
          success: true,
          result: {
            campaigns: [],
            activeCampaignIds: [],
          },
        });
      }

      // Store account insights data in meta_account_insights
      console.log(`Storing account insights for account ${accountId}...`);
      try {
        // Get account info with rate limiting
        const accountInfo = await withRateLimitRetry(
          async () => {
            return account.read([
              "name",
              "account_status",
              "amount_spent",
              "balance",
              "currency",
              "timezone_name",
              "timezone_offset_hours_utc",
              "business_country_code",
              "disable_reason",
              "is_prepay_account",
              "tax_id_status",
              "spend_cap",
            ]);
          },
          {
            accountId,
            endpoint: "account_info",
            callType: "READ",
            points: RATE_LIMIT_CONFIG.POINTS.READ,
            supabase,
          }
        );

        // Store enhanced account data
        const accountData = {
          account_id: accountId,
          name: accountInfo.name,
          account_status: accountInfo.account_status,
          amount_spent: parseFloat(accountInfo.amount_spent) || 0,
          balance: parseFloat(accountInfo.balance) || 0,
          currency: accountInfo.currency,
          spend_cap: parseFloat(accountInfo.spend_cap) || null,
          timezone_name: accountInfo.timezone_name,
          timezone_offset_hours_utc: accountInfo.timezone_offset_hours_utc,
          business_country_code: accountInfo.business_country_code,
          disable_reason: accountInfo.disable_reason,
          is_prepay_account: accountInfo.is_prepay_account,
          tax_id_status: accountInfo.tax_id_status,
          insights_start_date: new Date(dateRange.since),
          insights_end_date: new Date(dateRange.until),
          total_impressions: safeParseInt(
            accountInsights?.[0]?.impressions ?? "0"
          ),
          total_clicks: safeParseInt(accountInsights?.[0]?.clicks ?? "0"),
          total_reach: safeParseInt(accountInsights?.[0]?.reach ?? "0"),
          total_spend: parseFloat(accountInsights?.[0]?.spend ?? "0"),
          average_cpc: parseFloat(accountInsights?.[0]?.cpc ?? "0"),
          average_cpm: parseFloat(accountInsights?.[0]?.cpm ?? "0"),
          average_ctr: parseFloat(accountInsights?.[0]?.ctr ?? "0"),
          average_frequency: parseFloat(accountInsights?.[0]?.frequency ?? "0"),
          actions: accountInsights?.[0]?.actions || [],
          action_values: accountInsights?.[0]?.action_values || [],
          cost_per_action_type:
            accountInsights?.[0]?.cost_per_action_type || [],
          cost_per_unique_click: parseFloat(
            accountInsights?.[0]?.cost_per_unique_click ?? "0"
          ),
          outbound_clicks: accountInsights?.[0]?.outbound_clicks || [],
          outbound_clicks_ctr: parseFloat(
            accountInsights?.[0]?.outbound_clicks_ctr ?? "0"
          ),
          website_ctr: accountInsights?.[0]?.website_ctr || [],
          website_purchase_roas: parseFloat(
            accountInsights?.[0]?.website_purchase_roas ?? "0"
          ),
          last_updated: new Date(),
          is_data_complete: false, // This is 6-month data, not complete historical data
        };

        // Upsert with proper constraint
        const { error: upsertError } = await supabase
          .from("meta_account_insights")
          .upsert([accountData], {
            onConflict: "account_id",
            ignoreDuplicates: false,
          });

        if (upsertError) {
          console.error(`Error upserting account data: ${upsertError.message}`);
          console.error(
            "Full error details:",
            JSON.stringify(upsertError, null, 2)
          );
        } else {
          console.log(`Successfully stored account insights for ${accountId}`);
        }
      } catch (accountError) {
        console.error("Error storing account insights:", accountError);
        // Continue anyway, don't exit the function
      }
    } catch (activityError) {
      console.error("Error checking account activity:", activityError);
      return NextResponse.json(
        {
          error: "Error checking account activity",
          details:
            activityError instanceof Error
              ? activityError.message
              : String(activityError),
        },
        { status: 500 }
      );
    }

    // Process all campaigns in batches with proper cursor handling
    console.log("Fetching campaigns from Meta API...");
    console.time("campaigns-fetch");

    let processedCampaigns = [];
    let activeCampaignIds = [];
    let processedAdSets = []; // Add collection for ad sets
    let processedAds = []; // Add collection for ads
    let totalProcessed = 0;

    try {
      // Get first batch of campaigns with cursor-based pagination
      let campaigns = await withRateLimitRetry(
        async () => {
          return account.getCampaigns(
            [
              "name",
              "status",
              "objective",
              "daily_budget",
              "lifetime_budget",
              "configured_status",
              "effective_status",
              "bid_strategy",
              "budget_remaining",
              "buying_type",
              "special_ad_categories",
              "promoted_object",
              "recommendations",
              "spend_cap",
              "start_time",
              "end_time",
            ],
            {
              limit: batchSize,
            }
          );
        },
        {
          accountId,
          endpoint: "campaigns",
          callType: "READ",
          points: RATE_LIMIT_CONFIG.POINTS.READ,
          supabase,
        }
      );

      console.log(`Fetched first batch: ${campaigns.length} campaigns`);
      let hasMore = campaigns && campaigns.length > 0;

      // Process campaigns in batches with pagination
      while (hasMore && totalProcessed < maxCampaigns) {
        console.log(
          `Processing batch of ${campaigns.length} campaigns (total processed so far: ${totalProcessed})`
        );

        // Process each campaign in the batch
        for (const campaign of campaigns) {
          if (totalProcessed >= maxCampaigns) break;

          console.log(
            `Processing campaign ${totalProcessed + 1}: ${campaign.id} (${
              campaign.name
            })`
          );

          try {
            console.log(`Starting campaign processing for ${campaign.id}...`);

            // First check if this campaign had activity in last 24 hours
            console.log(`Checking activity for campaign ${campaign.id}...`);
            const campaignInsights = await withRateLimitRetry(
              async () => {
                return campaign.getInsights(
                  ["impressions", "clicks", "spend"],
                  {
                    time_range: dateRange,
                    level: "campaign",
                    breakdowns: [],
                  }
                );
              },
              {
                accountId,
                endpoint: `campaign_insights_${campaign.id}`,
                callType: "READ",
                points: RATE_LIMIT_CONFIG.POINTS.READ,
                supabase,
              }
            );

            // Check if the campaign had any activity
            const campaignHasActivity =
              campaignInsights &&
              campaignInsights.length > 0 &&
              (safeParseInt(campaignInsights[0]?.impressions) > 0 ||
                safeParseInt(campaignInsights[0]?.clicks) > 0 ||
                safeParseFloat(campaignInsights[0]?.spend) > 0);

            console.log(
              `Campaign ${campaign.id} activity: ${
                campaignHasActivity ? "Active" : "Inactive"
              }, impressions=${
                campaignInsights?.[0]?.impressions || 0
              }, clicks=${campaignInsights?.[0]?.clicks || 0}, spend=${
                campaignInsights?.[0]?.spend || 0
              }`
            );

            if (!campaignHasActivity) {
              console.log(
                `Skipping campaign ${campaign.id} - no activity in last 24 hours`
              );
              totalProcessed++;
              continue;
            }

            // Remember this campaign had activity
            activeCampaignIds.push(campaign.id);

            // Get full insights for active campaign
            console.log(
              `Fetching detailed insights for campaign ${campaign.id}...`
            );
            const fullInsights = await getInsights(
              campaign as InsightCapableEntity,
              supabase,
              accountId,
              dateRange
            );

            // Create campaign object with insights data
            const campaignData = {
              campaign_id: campaign.id,
              account_id: accountId,
              name: campaign.name,
              status: mapToValidStatus(campaign.status),
              objective: mapToValidObjective(campaign.objective),
              daily_budget: parseFloat(campaign.daily_budget) || 0,
              lifetime_budget: parseFloat(campaign.lifetime_budget) || 0,
              configured_status: campaign.configured_status,
              effective_status: campaign.effective_status,
              bid_strategy: campaign.bid_strategy,
              budget_remaining: parseFloat(campaign.budget_remaining) || 0,
              buying_type: campaign.buying_type,
              special_ad_categories: Array.isArray(
                campaign.special_ad_categories
              )
                ? campaign.special_ad_categories
                : [],
              promoted_object: campaign.promoted_object || null,
              recommendations: campaign.recommendations || null,
              spend_cap: parseFloat(campaign.spend_cap) || null,
              start_time: campaign.start_time
                ? new Date(campaign.start_time)
                : null,
              end_time: campaign.end_time ? new Date(campaign.end_time) : null,
              impressions: safeParseInt(fullInsights?.impressions),
              clicks: safeParseInt(fullInsights?.clicks),
              reach: safeParseInt(fullInsights?.reach),
              spend: safeParseFloat(fullInsights?.spend),
              cpc: safeParseFloat(fullInsights?.cpc),
              cpm: safeParseFloat(fullInsights?.cpm),
              ctr: safeParseFloat(fullInsights?.ctr),
              frequency: safeParseFloat(fullInsights?.frequency),
              actions: Array.isArray(fullInsights?.actions)
                ? fullInsights?.actions
                : [],
              action_values: Array.isArray(fullInsights?.action_values)
                ? fullInsights?.action_values
                : [],
              cost_per_action_type: Array.isArray(
                fullInsights?.cost_per_action_type
              )
                ? fullInsights?.cost_per_action_type
                : [],
              last_updated: new Date(),
            };

            // Save campaign to database using multi-step approach
            console.log(`Storing campaign ${campaign.id} to Supabase...`);

            try {
              // Step 1: Insert minimal data first
              const minimalData = {
                campaign_id: campaignData.campaign_id,
                account_id: campaignData.account_id,
                name: campaignData.name,
                status: campaignData.status,
                objective: campaignData.objective,
                daily_budget: campaignData.daily_budget,
                lifetime_budget: campaignData.lifetime_budget,
                configured_status: campaignData.configured_status,
                effective_status: campaignData.effective_status,
                bid_strategy: campaignData.bid_strategy || null,
                budget_remaining: campaignData.budget_remaining,
                buying_type: campaignData.buying_type || null,
                special_ad_categories: [],
                impressions: campaignData.impressions,
                clicks: campaignData.clicks,
                reach: campaignData.reach,
                spend: campaignData.spend,
                last_updated: campaignData.last_updated,
              };

              const { error: minError } = await supabase
                .from(CAMPAIGN_TABLE)
                .upsert([minimalData], {
                  onConflict: "campaign_id",
                  ignoreDuplicates: false,
                });

              if (minError) {
                console.error(
                  `Error with minimal data for campaign ${campaign.id}:`,
                  minError
                );
              } else {
                console.log(
                  `Successfully stored minimal data for campaign ${campaign.id}`
                );

                // Step 2: Update with full data and properly stringified JSON fields
                const updateData = {
                  campaign_id: campaignData.campaign_id,
                  account_id: campaignData.account_id,
                  name: campaignData.name,
                  status: campaignData.status,
                  objective: campaignData.objective,
                  daily_budget: campaignData.daily_budget,
                  lifetime_budget: campaignData.lifetime_budget,
                  configured_status: campaignData.configured_status,
                  effective_status: campaignData.effective_status,
                  bid_strategy: campaignData.bid_strategy,
                  budget_remaining: campaignData.budget_remaining,
                  buying_type: campaignData.buying_type,
                  special_ad_categories: JSON.stringify(
                    campaignData.special_ad_categories
                  ),
                  promoted_object: campaignData.promoted_object
                    ? JSON.stringify(campaignData.promoted_object)
                    : null,
                  recommendations: campaignData.recommendations
                    ? JSON.stringify(campaignData.recommendations)
                    : null,
                  spend_cap: campaignData.spend_cap,
                  start_time: campaignData.start_time,
                  end_time: campaignData.end_time,
                  impressions: campaignData.impressions,
                  clicks: campaignData.clicks,
                  reach: campaignData.reach,
                  spend: campaignData.spend,
                  cpc: campaignData.cpc,
                  cpm: campaignData.cpm,
                  ctr: campaignData.ctr,
                  frequency: campaignData.frequency,
                  actions: JSON.stringify(campaignData.actions),
                  action_values: JSON.stringify(campaignData.action_values),
                  cost_per_action_type: JSON.stringify(
                    campaignData.cost_per_action_type
                  ),
                  last_updated: campaignData.last_updated,
                };

                const { error: fullError } = await supabase
                  .from(CAMPAIGN_TABLE)
                  .upsert([updateData], {
                    onConflict: "campaign_id",
                    ignoreDuplicates: false,
                  });

                if (fullError) {
                  console.error(
                    `Error updating full data for campaign ${campaign.id}:`,
                    fullError
                  );
                  console.error(
                    `Full error details:`,
                    JSON.stringify(fullError, null, 2)
                  );

                  // Add advanced error analysis
                  if (fullError.message?.includes("array value")) {
                    console.error(
                      "Array value error detected. Some array fields may be causing issues."
                    );
                  } else if (fullError.message?.includes("json")) {
                    console.error(
                      "JSON parsing error detected. Some JSON fields may be malformed."
                    );
                  } else if (
                    fullError.message?.includes("invalid input syntax")
                  ) {
                    console.error(
                      "Invalid input syntax. Check data types of fields being inserted."
                    );
                  }

                  // Step 3: Fallback to just updating metrics if full update fails
                  try {
                    const basicMetrics = {
                      impressions: campaignData.impressions,
                      clicks: campaignData.clicks,
                      reach: campaignData.reach,
                      spend: campaignData.spend,
                      last_updated: campaignData.last_updated,
                    };

                    await supabase
                      .from(CAMPAIGN_TABLE)
                      .update(basicMetrics)
                      .eq("campaign_id", campaign.id);

                    console.log(
                      `Updated basic metrics for campaign ${campaign.id}`
                    );
                  } catch (metricsError) {
                    console.error(
                      `Error updating basic metrics for campaign ${campaign.id}:`,
                      metricsError
                    );
                  }
                } else {
                  console.log(
                    `Successfully updated full data for campaign ${campaign.id}`
                  );
                  processedCampaigns.push(campaignData);
                }

                // Now fetch and process ad sets
                console.log(`Fetching ad sets for campaign ${campaign.id}...`);

                try {
                  // Get ad sets with rate limiting
                  const adSets = await withRateLimitRetry(
                    async () => {
                      return campaign.getAdSets(
                        [
                          "name",
                          "status",
                          "daily_budget",
                          "lifetime_budget",
                          "bid_amount",
                          "billing_event",
                          "optimization_goal",
                          "targeting",
                          "bid_strategy",
                          "attribution_spec",
                          "promoted_object",
                          "pacing_type",
                          "configured_status",
                          "effective_status",
                          "destination_type",
                          "frequency_control_specs",
                          "is_dynamic_creative",
                          "issues_info",
                          "learning_stage_info",
                          "source_adset_id",
                          "targeting_optimization_types",
                          "use_new_app_click",
                          "start_time",
                          "end_time",
                        ],
                        { limit: 10 }
                      );
                    },
                    {
                      accountId,
                      endpoint: `campaign_adsets_${campaign.id}`,
                      callType: "READ",
                      points: RATE_LIMIT_CONFIG.POINTS.READ,
                      supabase,
                    }
                  );

                  console.log(
                    `Found ${adSets.length} ad sets for campaign ${campaign.id}`
                  );

                  // Process each ad set
                  for (const adSet of adSets) {
                    console.log(`Processing ad set ${adSet.id}...`);

                    // Check if ad set has insights data - only process with activity
                    const adSetInsights = await getInsights(
                      adSet as InsightCapableEntity,
                      supabase,
                      accountId,
                      dateRange
                    );

                    // Check if this ad set had activity
                    const adSetHasActivity =
                      adSetInsights &&
                      (safeParseInt(adSetInsights.impressions) > 0 ||
                        safeParseInt(adSetInsights.clicks) > 0 ||
                        safeParseFloat(adSetInsights.spend) > 0);

                    console.log(
                      `Ad set ${adSet.id} activity: ${
                        adSetHasActivity ? "Active" : "Inactive"
                      }`
                    );

                    if (!adSetHasActivity) {
                      console.log(
                        `Skipping ad set ${adSet.id} - no activity in last 24 hours`
                      );
                      continue;
                    }

                    // Store enhanced ad set data
                    const adSetData = {
                      ad_set_id: adSet.id,
                      account_id: accountId,
                      campaign_id: campaign.id,
                      name: adSet.name,
                      status: mapToValidStatus(adSet.status),
                      daily_budget: parseFloat(adSet.daily_budget) || 0,
                      lifetime_budget: parseFloat(adSet.lifetime_budget) || 0,
                      bid_amount: parseFloat(adSet.bid_amount) || 0,
                      billing_event: adSet.billing_event,
                      optimization_goal: adSet.optimization_goal,
                      targeting: adSet.targeting,
                      bid_strategy: adSet.bid_strategy,
                      attribution_spec: adSet.attribution_spec,
                      promoted_object: adSet.promoted_object,
                      pacing_type: Array.isArray(adSet.pacing_type)
                        ? adSet.pacing_type
                        : [],
                      configured_status: adSet.configured_status,
                      effective_status: adSet.effective_status,
                      destination_type: adSet.destination_type,
                      frequency_control_specs: adSet.frequency_control_specs,
                      is_dynamic_creative: adSet.is_dynamic_creative,
                      issues_info: Array.isArray(adSet.issues_info)
                        ? adSet.issues_info
                        : [],
                      learning_stage_info: adSet.learning_stage_info,
                      source_adset_id: adSet.source_adset_id,
                      targeting_optimization_types: Array.isArray(
                        adSet.targeting_optimization_types
                      )
                        ? adSet.targeting_optimization_types
                        : [],
                      use_new_app_click: adSet.use_new_app_click,
                      start_time: adSet.start_time
                        ? new Date(adSet.start_time)
                        : null,
                      end_time: adSet.end_time
                        ? new Date(adSet.end_time)
                        : null,
                      impressions: safeParseInt(adSetInsights?.impressions),
                      clicks: safeParseInt(adSetInsights?.clicks),
                      reach: safeParseInt(adSetInsights?.reach),
                      spend: safeParseFloat(adSetInsights?.spend),
                      last_updated: new Date(),
                    };

                    // Apply the same multi-step approach for ad sets
                    console.log(
                      `Storing ad set ${adSet.id} to meta_ad_sets...`
                    );

                    try {
                      // Step 1: Insert minimal ad set data first
                      const minimalAdSetData = {
                        ad_set_id: adSetData.ad_set_id,
                        account_id: adSetData.account_id,
                        campaign_id: adSetData.campaign_id,
                        name: adSetData.name,
                        status: adSetData.status,
                        impressions: adSetData.impressions,
                        clicks: adSetData.clicks,
                        reach: adSetData.reach,
                        spend: adSetData.spend,
                        last_updated: adSetData.last_updated,
                      };

                      const { error: minAdSetError } = await supabase
                        .from("meta_ad_sets")
                        .upsert([minimalAdSetData], {
                          onConflict: "ad_set_id",
                          ignoreDuplicates: false,
                        });

                      if (minAdSetError) {
                        console.error(
                          `Error storing minimal data for ad set ${adSet.id}:`,
                          minAdSetError
                        );
                      } else {
                        console.log(
                          `Successfully stored minimal data for ad set ${adSet.id}`
                        );

                        // Step 2: Update with full ad set data with properly stringified JSON fields
                        const updateAdSetData = {
                          ...minimalAdSetData,
                          daily_budget: adSetData.daily_budget,
                          lifetime_budget: adSetData.lifetime_budget,
                          bid_amount: adSetData.bid_amount,
                          billing_event: adSetData.billing_event,
                          optimization_goal: adSetData.optimization_goal,
                          targeting: adSetData.targeting
                            ? JSON.stringify(adSetData.targeting)
                            : null,
                          bid_strategy: adSetData.bid_strategy,
                          attribution_spec: adSetData.attribution_spec
                            ? JSON.stringify(adSetData.attribution_spec)
                            : null,
                          promoted_object: adSetData.promoted_object
                            ? JSON.stringify(adSetData.promoted_object)
                            : null,
                          pacing_type: JSON.stringify(adSetData.pacing_type),
                          configured_status: adSetData.configured_status,
                          effective_status: adSetData.effective_status,
                          destination_type: adSetData.destination_type,
                          frequency_control_specs:
                            adSetData.frequency_control_specs
                              ? JSON.stringify(
                                  adSetData.frequency_control_specs
                                )
                              : null,
                          is_dynamic_creative: adSetData.is_dynamic_creative,
                          issues_info: JSON.stringify(adSetData.issues_info),
                          learning_stage_info: adSetData.learning_stage_info
                            ? JSON.stringify(adSetData.learning_stage_info)
                            : null,
                          source_adset_id: adSetData.source_adset_id,
                          targeting_optimization_types: JSON.stringify(
                            adSetData.targeting_optimization_types
                          ),
                          use_new_app_click: adSetData.use_new_app_click,
                          start_time: adSetData.start_time,
                          end_time: adSetData.end_time,
                        };

                        const { error: fullAdSetError } = await supabase
                          .from("meta_ad_sets")
                          .upsert([updateAdSetData], {
                            onConflict: "ad_set_id",
                            ignoreDuplicates: false,
                          });

                        if (fullAdSetError) {
                          console.error(
                            `Error updating full data for ad set ${adSet.id}:`,
                            fullAdSetError
                          );

                          // Step 3: Fallback to just updating metrics if full update fails
                          try {
                            const basicAdSetMetrics = {
                              impressions: adSetData.impressions,
                              clicks: adSetData.clicks,
                              reach: adSetData.reach,
                              spend: adSetData.spend,
                              last_updated: adSetData.last_updated,
                            };

                            await supabase
                              .from("meta_ad_sets")
                              .update(basicAdSetMetrics)
                              .eq("ad_set_id", adSet.id);

                            console.log(
                              `Updated basic metrics for ad set ${adSet.id}`
                            );

                            // Add ad set with basic metrics to our collection
                            processedAdSets.push({
                              ad_set_id: adSet.id,
                              campaign_id: campaign.id,
                              name: adSet.name,
                              status: adSetData.status,
                              impressions: adSetData.impressions,
                              clicks: adSetData.clicks,
                              spend: adSetData.spend,
                            });
                          } catch (metricsError) {
                            console.error(
                              `Error updating basic metrics for ad set ${adSet.id}:`,
                              metricsError
                            );
                          }
                        } else {
                          console.log(
                            `Successfully updated full data for ad set ${adSet.id}`
                          );

                          // Add successfully processed ad set to our collection
                          processedAdSets.push({
                            ad_set_id: adSet.id,
                            campaign_id: campaign.id,
                            name: adSet.name,
                            status: adSetData.status,
                            daily_budget: adSetData.daily_budget,
                            lifetime_budget: adSetData.lifetime_budget,
                            impressions: adSetData.impressions,
                            clicks: adSetData.clicks,
                            spend: adSetData.spend,
                          });

                          // Now fetch and process ads for this ad set
                          console.log(`Fetching ads for ad set ${adSet.id}...`);

                          try {
                            // Get ads with rate limiting
                            const ads = await withRateLimitRetry(
                              async () => {
                                return adSet.getAds(
                                  [
                                    "name",
                                    "status",
                                    "creative",
                                    "tracking_specs",
                                    "conversion_specs",
                                    "preview_shareable_link",
                                    "effective_object_story_id",
                                    "configured_status",
                                    "effective_status",
                                    "issues_info",
                                    "source_ad_id",
                                    "engagement_audience",
                                    "object_story_spec",
                                    "recommendations",
                                    "tracking_and_conversion_specs",
                                  ],
                                  { limit: 10 }
                                );
                              },
                              {
                                accountId,
                                endpoint: `adset_ads_${adSet.id}`,
                                callType: "READ",
                                points: RATE_LIMIT_CONFIG.POINTS.READ,
                                supabase,
                              }
                            );

                            console.log(
                              `Found ${ads.length} ads for ad set ${adSet.id}`
                            );

                            // Process each ad
                            for (const ad of ads) {
                              try {
                                console.log(`Processing ad ${ad.id}...`);

                                // Get ad insights to check for activity
                                const adInsights = await getInsights(
                                  ad as InsightCapableEntity,
                                  supabase,
                                  accountId,
                                  dateRange
                                );

                                // Check if this ad had activity
                                const adHasActivity =
                                  adInsights &&
                                  (safeParseInt(adInsights.impressions) > 0 ||
                                    safeParseInt(adInsights.clicks) > 0 ||
                                    safeParseFloat(adInsights.spend) > 0);

                                console.log(
                                  `Ad ${ad.id} activity: ${
                                    adHasActivity ? "Active" : "Inactive"
                                  }`
                                );

                                if (!adHasActivity) {
                                  console.log(
                                    `Skipping ad ${ad.id} - no activity in last 24 hours`
                                  );
                                  continue;
                                }

                                // Get creative details if creative exists
                                let creativeDetails = null;
                                if (ad.creative && ad.creative.id) {
                                  try {
                                    // Use direct creative ID lookup
                                    const creative = new AdCreative(
                                      ad.creative.id
                                    );
                                    const details = await creative.read([
                                      "id",
                                      "name",
                                      "title",
                                      "body",
                                      "object_type",
                                      "thumbnail_url",
                                      "image_url",
                                      "video_id",
                                      "url_tags",
                                      "template_url",
                                      "instagram_permalink_url",
                                      "effective_object_story_id",
                                      "asset_feed_spec",
                                      "object_story_spec",
                                      "platform_customizations",
                                    ]);

                                    if (details) {
                                      creativeDetails = {
                                        thumbnail_url:
                                          details.thumbnail_url ||
                                          details.image_url,
                                        creative_type: details.object_type,
                                        asset_feed_spec:
                                          details.asset_feed_spec,
                                        url_tags: details.url_tags,
                                        template_url: details.template_url,
                                        instagram_permalink_url:
                                          details.instagram_permalink_url,
                                        effective_object_story_id:
                                          details.effective_object_story_id,
                                      };
                                    }
                                  } catch (creativeError) {
                                    console.error(
                                      `Error fetching creative details for ad ${ad.id}:`,
                                      creativeError
                                    );
                                    // Continue without creative details
                                  }
                                }

                                // Apply a direct, simplified approach for ads
                                console.log(
                                  `Directly storing ad ${ad.id} to meta_ads...`
                                );

                                // Add the ad to our collection BEFORE database operations
                                // This ensures the ad is returned to the client even if database operations fail
                                const simpleAdRecord = {
                                  ad_id: ad.id,
                                  name: ad.name,
                                  ad_set_id: adSet.id,
                                  campaign_id: campaign.id,
                                  status: mapToValidStatus(
                                    ad.status || "PAUSED"
                                  ),
                                  impressions: safeParseInt(
                                    adInsights?.impressions
                                  ),
                                  clicks: safeParseInt(adInsights?.clicks),
                                  spend: safeParseFloat(adInsights?.spend),
                                  reach: safeParseInt(adInsights?.reach),
                                };

                                // Add to processed ads collection first - this is critical
                                processedAds.push(simpleAdRecord);

                                try {
                                  // Create a record with only the essential fields
                                  const adRecord = {
                                    ad_id: ad.id,
                                    name: ad.name,
                                    status: mapToValidStatus(
                                      ad.status || "PAUSED"
                                    ),
                                    account_id: accountId,
                                    campaign_id: campaign.id,
                                    ad_set_id: adSet.id,
                                    impressions: safeParseInt(
                                      adInsights?.impressions
                                    ),
                                    clicks: safeParseInt(adInsights?.clicks),
                                    reach: safeParseInt(adInsights?.reach),
                                    spend: safeParseFloat(adInsights?.spend),
                                    last_updated: new Date(),
                                  };

                                  // Simple and direct upsert to meta_ads
                                  const { error: adError } = await supabase
                                    .from("meta_ads")
                                    .upsert([adRecord], {
                                      onConflict: "ad_id",
                                      ignoreDuplicates: false,
                                    });

                                  if (adError) {
                                    console.error(
                                      `Error storing ad ${ad.id}:`,
                                      adError
                                    );

                                    // Try with an even more minimal record if there was an error
                                    const minimalRecord = {
                                      ad_id: ad.id,
                                      name: ad.name,
                                      last_updated: new Date(),
                                    };

                                    const { error: minimalError } =
                                      await supabase
                                        .from("meta_ads")
                                        .upsert([minimalRecord], {
                                          onConflict: "ad_id",
                                          ignoreDuplicates: false,
                                        });

                                    if (minimalError) {
                                      console.error(
                                        `Minimal record insert also failed for ad ${ad.id}:`,
                                        minimalError
                                      );
                                    } else {
                                      console.log(
                                        `Successfully stored minimal data for ad ${ad.id}`
                                      );
                                    }
                                  } else {
                                    console.log(
                                      `Successfully stored data for ad ${ad.id}`
                                    );

                                    // If creative details exist and initial upsert succeeded,
                                    // try to update with creative details
                                    if (creativeDetails) {
                                      try {
                                        const creativeUpdate = {
                                          ad_id: ad.id,
                                          thumbnail_url:
                                            creativeDetails.thumbnail_url,
                                          creative_type:
                                            creativeDetails.creative_type,
                                          asset_feed_spec:
                                            creativeDetails.asset_feed_spec
                                              ? JSON.stringify(
                                                  creativeDetails.asset_feed_spec
                                                )
                                              : null,
                                          url_tags: creativeDetails.url_tags,
                                          template_url:
                                            creativeDetails.template_url,
                                          instagram_permalink_url:
                                            creativeDetails.instagram_permalink_url,
                                          effective_object_story_id:
                                            creativeDetails.effective_object_story_id,
                                        };

                                        await supabase
                                          .from("meta_ads")
                                          .update(creativeUpdate)
                                          .eq("ad_id", ad.id);

                                        console.log(
                                          `Updated creative details for ad ${ad.id}`
                                        );
                                      } catch (creativeUpdateError) {
                                        console.error(
                                          `Error updating creative details for ad ${ad.id}:`,
                                          creativeUpdateError
                                        );
                                      }
                                    }
                                  }
                                } catch (adError) {
                                  console.error(
                                    `Exception storing ad ${ad.id}:`,
                                    adError
                                  );
                                  // No need to handle this error further since the ad is already in processedAds
                                }

                                // Add a small delay between ads to avoid overwhelming the API
                                await delay(500);
                              } catch (adError) {
                                console.error(
                                  `Error processing ad ${ad.id}:`,
                                  adError
                                );
                              }
                            } // End ad processing
                          } catch (adsError) {
                            console.error(
                              `Error fetching ads for ad set ${adSet.id}:`,
                              adsError
                            );
                          }
                        }
                      }
                    } catch (adSetError) {
                      console.error(
                        `Exception storing ad set ${adSet.id}:`,
                        adSetError
                      );
                    }

                    // Add a small delay between ad sets
                    await delay(500);
                  } // End ad set processing
                } catch (adSetsError) {
                  console.error(
                    `Error fetching ad sets for campaign ${campaign.id}:`,
                    adSetsError
                  );
                }
              }
              try {
                // Empty try block to fix syntax error
              } catch (fullError) {
                console.error(
                  `Error updating full data for campaign ${campaign.id}:`,
                  fullError
                );
              }
            } catch (supabaseError) {
              console.error(
                `Exception during campaign ${campaign.id} storage:`,
                supabaseError
              );
              console.error(
                `Stack trace:`,
                supabaseError instanceof Error
                  ? supabaseError.stack
                  : "No stack trace"
              );
              totalProcessed++;
            }
          } catch (supabaseError) {
            console.error(
              `Exception during campaign ${campaign.id} storage:`,
              supabaseError
            );
            console.error(
              `Stack trace:`,
              supabaseError instanceof Error
                ? supabaseError.stack
                : "No stack trace"
            );
            totalProcessed++;
          }
        }

        // Check if we need to fetch more campaigns using cursor-based pagination
        if (campaigns.hasNext() && totalProcessed < maxCampaigns) {
          console.log("Fetching next page of campaigns...");
          try {
            // Use the campaigns.next() function to get the next page
            campaigns = await withRateLimitRetry(async () => campaigns.next(), {
              accountId,
              endpoint: "campaigns_pagination",
              callType: "READ",
              points: RATE_LIMIT_CONFIG.POINTS.READ,
              supabase,
            });
            console.log(`Fetched next page: ${campaigns.length} campaigns`);

            // Ensure we continue only if we got campaigns
            hasMore = campaigns && campaigns.length > 0;
          } catch (paginationError) {
            console.error("Error fetching next page:", paginationError);
            hasMore = false;
          }
        } else {
          hasMore = false;
        }
      }
    } catch (fetchError) {
      console.error("Error fetching campaigns:", fetchError);
      return NextResponse.json(
        {
          error: "Error fetching campaigns",
          details:
            fetchError instanceof Error
              ? fetchError.message
              : String(fetchError),
        },
        { status: 500 }
      );
    }

    console.timeEnd("campaigns-fetch");
    console.log(
      `Successfully processed ${processedCampaigns.length} active campaigns out of ${totalProcessed} total`
    );

    // Return success response
    console.log("Generating response");
    const response = NextResponse.json({
      result: {
        campaigns: processedCampaigns,
        activeCampaignIds,
        adSets: processedAdSets,
        ads: processedAds,
        total: processedCampaigns.length,
        processed: totalProcessed,
        adSetsProcessed: processedAdSets.length,
        adsProcessed: processedAds.length,
        dateRange,
      },
      success: true,
      message: `Found ${processedCampaigns.length} campaigns with ${processedAdSets.length} ad sets and ${processedAds.length} ads in the last 24 hours`,
    });

    console.log("Response object created");
    console.timeEnd("total-request-time");
    return response;
  } catch (error) {
    console.error("=== Error in Meta Marketing Daily API ===");
    console.error("Full error object:", error);
    console.error(
      "Error message:",
      error instanceof Error ? error.message : String(error)
    );

    // Handle specific error types
    const apiError = error as any;
    const errorCode = apiError?.response?.error?.code;
    const errorMessage = apiError?.response?.error?.message;

    // Handle permission errors
    if (errorCode === 200) {
      return NextResponse.json(
        {
          error: "Facebook API authorization error",
          details:
            "The application doesn't have the required permissions. Please check your access token and ensure it has ads_management or ads_read permissions.",
          originalMessage: errorMessage,
        },
        { status: 403 }
      );
    }

    // Handle rate limit errors
    if (errorCode === 17) {
      return NextResponse.json(
        {
          error: "Rate limit reached. Please try again in a few minutes.",
          retryAfter: RATE_LIMIT_CONFIG.STANDARD.BLOCK_TIME,
        },
        { status: 429 }
      );
    }

    return NextResponse.json(
      {
        error:
          error instanceof Error ? error.message : "Unknown error occurred",
      },
      { status: 500 }
    );
  }
}

// POST handler for creating campaigns and ad sets
export async function POST(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get("action");
    const data = await request.json();

    const account = new AdAccount(data.accountId);
    const supabase = await createClient();

    let result;
    let supabaseResult;

    switch (action) {
      case "createCampaign":
        try {
          result = await account.createCampaign(["id"], {
            name: data.name,
            objective: data.objective,
            status: data.status,
            special_ad_categories: [],
          });

          // Store in Supabase
          const campaignData = {
            campaign_id: result.id,
            account_id: data.accountId,
            name: data.name,
            status: mapToValidStatus(data.status),
            objective: mapToValidObjective(data.objective),
          };

          console.log(
            `Campaign data for insert:`,
            JSON.stringify(campaignData)
          );

          const { data: insertedData, error: supabaseError } = await supabase
            .from("meta_campaigns")
            .insert([campaignData]);

          console.log("insertedData", insertedData, supabaseError);

          if (supabaseError) {
            console.error("Supabase error:", supabaseError);
            throw new Error("Failed to store campaign data");
          }

          supabaseResult = insertedData;
        } catch (error) {
          console.error("Error creating campaign:", error);
          throw error;
        }
        break;

      case "createAdSet":
        try {
          result = await account.createAdSet(["id"], {
            name: data.name,
            campaign_id: data.campaignId,
            daily_budget: data.dailyBudget,
            start_time: data.startTime,
            end_time: data.endTime,
            bid_amount: data.bidAmount,
            billing_event: data.billingEvent,
            optimization_goal: data.optimizationGoal,
            targeting: data.targeting,
            status: data.status,
          });

          // Store in Supabase
          const adSetData = {
            ad_set_id: result.id,
            campaign_id: data.campaignId,
            name: data.name,
            status: data.status,
            daily_budget: data.dailyBudget,
            bid_amount: data.bidAmount,
            billing_event: data.billingEvent,
            optimization_goal: data.optimizationGoal,
            targeting: data.targeting,
            start_time: data.startTime ? new Date(data.startTime) : undefined,
            end_time: data.endTime ? new Date(data.endTime) : undefined,
          };

          const { data: insertedData, error: supabaseError } = await supabase
            .from("meta_ad_sets")
            .insert([adSetData]);

          console.log("insertedData", insertedData, supabaseError);

          if (supabaseError) {
            console.error("Supabase error:", supabaseError);
            throw new Error("Failed to store ad set data");
          }

          supabaseResult = insertedData;
        } catch (error) {
          console.error("Error creating ad set:", error);
          throw error;
        }
        break;

      default:
        return NextResponse.json({ error: "Invalid action" }, { status: 400 });
    }

    return NextResponse.json({ result, supabaseResult });
  } catch (error) {
    console.error("Error:", error);
    if (error instanceof Error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    return NextResponse.json(
      { error: "Unknown error occurred" },
      { status: 500 }
    );
  }
}

// Helper function to map Meta API objectives to our database enum values
function mapToValidObjective(objective: string): string {
  // Valid values in our database enum
  const validObjectives = [
    "OUTCOME_AWARENESS",
    "OUTCOME_ENGAGEMENT",
    "OUTCOME_SALES",
    "OUTCOME_LEADS",
    "OUTCOME_TRAFFIC",
    "OUTCOME_APP_PROMOTION",
    "OUTCOME_CONVERSIONS",
  ];

  // Direct mapping
  const objectiveMap: Record<string, string> = {
    AWARENESS: "OUTCOME_AWARENESS",
    REACH: "OUTCOME_AWARENESS",
    BRAND_AWARENESS: "OUTCOME_AWARENESS",
    ENGAGEMENT: "OUTCOME_ENGAGEMENT",
    POST_ENGAGEMENT: "OUTCOME_ENGAGEMENT",
    PAGE_LIKES: "OUTCOME_ENGAGEMENT",
    EVENT_RESPONSES: "OUTCOME_ENGAGEMENT",
    VIDEO_VIEWS: "OUTCOME_ENGAGEMENT",
    SALES: "OUTCOME_SALES",
    PRODUCT_CATALOG_SALES: "OUTCOME_SALES",
    STORE_TRAFFIC: "OUTCOME_SALES",
    LINK_CLICKS: "OUTCOME_TRAFFIC",
    WEBSITE_TRAFFIC: "OUTCOME_TRAFFIC",
    LEAD_GENERATION: "OUTCOME_LEADS",
    LEADS: "OUTCOME_LEADS",
    APP_INSTALLS: "OUTCOME_APP_PROMOTION",
    MOBILE_APP_INSTALLS: "OUTCOME_APP_PROMOTION",
    APP_ENGAGEMENT: "OUTCOME_APP_PROMOTION",
    MOBILE_APP_ENGAGEMENT: "OUTCOME_APP_PROMOTION",
    CONVERSIONS: "OUTCOME_CONVERSIONS",
    WEBSITE_CONVERSIONS: "OUTCOME_CONVERSIONS",
    OUTCOME_AWARENESS: "OUTCOME_AWARENESS",
    OUTCOME_ENGAGEMENT: "OUTCOME_ENGAGEMENT",
    OUTCOME_SALES: "OUTCOME_SALES",
    OUTCOME_LEADS: "OUTCOME_LEADS",
    OUTCOME_TRAFFIC: "OUTCOME_TRAFFIC",
    OUTCOME_APP_PROMOTION: "OUTCOME_APP_PROMOTION",
    OUTCOME_CONVERSIONS: "OUTCOME_CONVERSIONS",
  };

  // If we have a direct mapping, use it
  if (objective in objectiveMap) {
    return objectiveMap[objective];
  }

  // If the objective is already a valid enum value, return it
  if (validObjectives.includes(objective)) {
    return objective;
  }

  // Default fallback if we can't map it
  console.warn(
    `Could not map objective '${objective}' to a valid enum value, using OUTCOME_AWARENESS as default`
  );
  return "OUTCOME_AWARENESS";
}

// Helper function to map Meta API status to our database enum values
function mapToValidStatus(status: string): string {
  // Valid values in our database enum
  const validStatuses = ["ACTIVE", "PAUSED", "DELETED", "ARCHIVED"];

  // Direct mapping
  const statusMap: Record<string, string> = {
    ACTIVE: "ACTIVE",
    PAUSED: "PAUSED",
    DELETED: "DELETED",
    ARCHIVED: "ARCHIVED",
  };

  // If we have a direct mapping, use it
  if (status.toUpperCase() in statusMap) {
    return statusMap[status.toUpperCase()];
  }

  // If the status is already a valid enum value, return it
  if (validStatuses.includes(status)) {
    return status;
  }

  // Default fallback if we can't map it
  console.warn(
    `Could not map status '${status}' to a valid enum value, using PAUSED as default`
  );
  return "PAUSED";
}
